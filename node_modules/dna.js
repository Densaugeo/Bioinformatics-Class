(function(exports) {

// Reverse and complement DNA string
var reverseComplement = exports.reverseComplement = function reverseComplement(string) {
  var result = '', complements = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'};
  
  // Step backwards through array for reverse iteration
  for(var i = string.length; i--;) {
    result += complements[string[i]];
  }
  
  return result;
}

// Find all matches of pattern in sequence
var findMatches = exports.findMatches = function findMatches(sequence, pattern) {
  var result = [];
  
  for(var last = sequence.indexOf(pattern); last !== -1; last = sequence.indexOf(pattern, last + 1)) {
    result.push(last);
  }
  
  return result;
}

// Find near matches of pattern in sequence, with no more than d mismatched nucleotides
var findApproximateMatches = exports.findApproximateMatches = function findApproximateMatches(sequence, pattern, d) {
  var result = [], subsequence = '', k = pattern.length, differences = 0;
  
  for(var position = 0, end = sequence.length - pattern.length; position <= end; ++position) {
    subsequence = sequence.substr(position, k);
    
    differences = 0;
    for(var j = 0; j < k; ++j) {
      if(subsequence[j] !== pattern[j]) ++differences;
    }
    
    if(differences <= d) result.push(position);
  }
  
  return result;
}

// Find all clumps of kmers which appear at least t times in any substring of length L in the given genome
var findClumps = exports.findClumps = function findClumps (genome, k, L, t) {
  var results = [], clumps = {}, kmers = {}, newString = '', oldString = '';
  
  for(var position = 0, end = genome.length - k; position <= end; ++position) {
    // Catalogue each kmer in kmers object, and remove old kmers from before the current substring of length L
    newString = genome.substr(position, k);
    kmers[newString] = (kmers[newString] || 0) + 1;
    if(position >= L) --kmers[genome.substr(position - L, k)];
    
    // Check for clumps
    if(kmers[newString] >= t) clumps[newString] = {};
  }
  
  for(var i in clumps) results.push(i);
  return results;
}

// Find indices of minimum G - C skew (0 based indexing)
var minimumSkew = exports.minimumSkew = function minimumSkew(sequence) {
  var lowestPoints = [-1], lowestValue = 0, skew = 0, skewValue = {'A': 0, 'T': 0, 'C': -1, 'G': 1};
  
  for(var i = 0, length = sequence.length; i < length; ++i) {
    skew += skewValue[sequence[i]];
    
    if(skew === lowestValue) {
      lowestPoints.push(i);
    }
    if(skew < lowestValue) {
      lowestPoints = [i];
      lowestValue = skew;
    }
  }

  return {points: lowestPoints, value: lowestValue};
}

// Find most common kmer(s) in sequence
var frequentWords = exports.frequentWords = function frequentWords(sequence, k) {
  var kmers = {}, frequentKmers = [], highestFrequency = 0, subsequence = '';
  
  for(var i = 0, end = sequence.length - k; i <= end; ++i) {
    subsequence = sequence.substr(i, k);
    
    kmers[subsequence] = (kmers[subsequence] || 0) + 1;
    if(kmers[subsequence] === highestFrequency) {
      frequentKmers.push(subsequence);
    }
    if(kmers[subsequence] > highestFrequency) {
      frequentKmers = [subsequence];
      highestFrequency = kmers[subsequence];
    }
  }
  
  return {frequency: highestFrequency, kmers: frequentKmers};
}

var changeBase = exports.changeBase = {
  'A': {'T': 1, 'C': 2, 'G': 3},
  'T': {'C': 1, 'G': 2, 'A': 3},
  'C': {'G': 1, 'A': 2, 'T': 3},
  'G': {'A': 1, 'T': 2, 'C': 3}
};

// Find most common kmer(s) in sequence, counting occurences of a kmer with no more than d differences (rather than exact occurences)
// If complements option is true, count kmers together with their complements
var frequentApproximateWords = exports.frequentApproximateWords = function frequentApproximateWords(sequence, k, d, complements) {
  if(d > 3) throw new Error('Sorry, I can only do d values of up to 3');
  console.warn('This function is complicated and untested - use at your own (high) risk')
  
  var kmers = {}, frequentKmers = [], highestFrequency = 0, subsequence = '', nearSubsequece = '', frequency = 0;
  
  for(var i = 0, end = sequence.length - k; i <= end; ++i) {
    subsequence = sequence.substr(i, k);
    
    // Make note of the subsequence, along with all similar subsequences
    kmers[subsequence] = (kmers[subsequence] || 0) + 1;
    if(d >= 1) for(var i2 = 0; i2 < k; ++i2) for(var i3 in changeBase[subsequence[i2]]) {
      nearSubsequence = subsequence.substring(0, i2) + i3 + subsequence.substring(i2 + 1);
      kmers[nearSubsequence] = (kmers[nearSubsequence] || 0) + 1;
    }
    if(d >= 2) for(var i2 = 0; i2 < k; ++i2) for(var i3 = i2 + 1; i3 < k; ++i3) {
      for(var i4 in changeBase[subsequence[i2]]) for(var i5 in changeBase[subsequence[i3]]) {
        nearSubsequence = subsequence.substring(0, i2) + i4 + subsequence.substring(i2 + 1, i3) + i5 + subsequence.substring(i3 + 1);
        kmers[nearSubsequence] = (kmers[nearSubsequence] || 0) + 1;
      }
    }
    if(d >= 3) for(var i2 = 0; i2 < k; ++i2) for(var i3 = i2 + 1; i3 < k; ++i3) for(var i4 = i3 + 1; i4 < k; ++i4) {
      for(var i5 in changeBase[subsequence[i2]]) for(var i6 in changeBase[subsequence[i3]]) for(var i7 in changeBase[subsequence[i4]]) {
        nearSubsequence = subsequence.substring(0, i2) + i5 + subsequence.substring(i2 + 1, i3) + i6 + subsequence.substring(i3 + 1, i4) + i7 + subsequence.substring(i4 + 1);
        kmers[nearSubsequence] = (kmers[nearSubsequence] || 0) + 1;
      }
    }
  }
  
  for(var i in kmers) {
    frequency = kmers[i] + (complements ? kmers[reverseComplement(i)] : 0);
    
    if(frequency === highestFrequency) {
      frequentKmers.push(i);
    }
    if(frequency > highestFrequency) {
      frequentKmers = [i];
      highestFrequency = frequency;
    }
  }
  
  return {frequency: highestFrequency, kmers: frequentKmers};
}

// Given key list of dna strands, find any (k, d)-motif appearing in each
var findMotifs = exports.findMotifs = function findMotifs(dnas, k, d) {
  var kmers = {}, kmersWithDiffs = {}, results = {}, isPresent = false;
  
  if(dnas.constructor.name !== 'Object') throw new TypeError('Parameter \'dnas\' must be a key list of dna strings');
  
  // Enumerate all kmers
  for(var dna in dnas) {
    for(var i = 0, endi = dna.length - k; i <= endi; ++i) {
      kmers[dna.substr(i, k)] = true;
    }
  }
  
  // Enumerate all kmers with no more than d differences from the original kmers
  kmersWithDiffs = listVariations(kmers, d);
  
  // Screen for appearance in each strand
  for(var kmer in kmersWithDiffs) {
    isPresent = true;
    
    for(var dna in dnas) {
      if(hammingDistance(kmer, dna) > d) isPresent = false;
    }
    
    if(isPresent) results[kmer] = true;
  }
  
  return results;
}

// Find hamming distance between two strings...just like it sounds
var hammingDistance = exports.hammingDistance = function hammingDistance(s1, s2) {
  // If both strings are the same length, they can be put either variable
  var short = s1.length > s2.length ? s2 : s1;
  var long  = s1.length > s2.length ? s1 : s2;
  var distanceCurrent, distance = Number.MAX_VALUE;
  
  for(var i = 0, endi = long.length - short.length; i <= endi; ++i) {
    distanceCurrent = 0;
    
    for(var j = 0, endj = short.length; j < endj; ++j) {
      if(short[j] !== long[i + j]) ++distanceCurrent;
    }
    
    if(distanceCurrent < distance) distance = distanceCurrent;
  }
  
  return distance;
}

// List all variations of a key list of sequences with at most d differencs from one of the originals
// 'sequences' must be represented as an object with keys matching the desired sequences, for ease of implementation
var listVariations = exports.listVariations = function listVariations(sequences, d) {
  if(sequences.constructor.name !== 'Object') throw new TypeError('Parameter \'sequences\' must be represented as a key list');
  
  var results = {};
  for(var sequence in sequences) results[sequence] = true;
  
  if(d === 0) return results;
  
  if(d > 0) {
    for(var sequence in sequences) {
      for(var j = 0, endj = sequence.length; j < endj; ++j) {
        for(var k in changeBase[sequence[j]]) {
          results[sequence.substring(0, j) + k + sequence.substring(j + 1)] = true;
        }
      }
    }
  }
  
  if(d === 1) return results;
  
  if(d > 1) {
    return listVariations(results, d - 1);
  }
}

// Lookup table for converting DNA nucleotides to RNA
var DNA_TO_RNA = exports.DNA_TO_RNA = {'A': 'A', 'T': 'U', 'C': 'C', 'G': 'G'};

// Lookup table for converting RNA codons to one-letter amino acid codes
var RNA_TO_AMINES = exports.RNA_TO_AMINES = {
  AAA: 'K', AAU: 'N', AAC: 'N', AAG: 'K',
  AUA: 'I', AUU: 'I', AUC: 'I', AUG: 'M',
  ACA: 'T', ACU: 'T', ACC: 'T', ACG: 'T',
  AGA: 'R', AGU: 'S', AGC: 'S', AGG: 'R',
  UAA: ' ', UAU: 'Y', UAC: 'Y', UAG: ' ',
  UUA: 'L', UUU: 'F', UUC: 'F', UUG: 'L',
  UCA: 'S', UCU: 'S', UCC: 'S', UCG: 'S',
  UGA: ' ', UGU: 'C', UGC: 'C', UGG: 'W',
  CAA: 'Q', CAU: 'H', CAC: 'H', CAG: 'Q',
  CUA: 'L', CUU: 'L', CUC: 'L', CUG: 'L',
  CCA: 'P', CCU: 'P', CCC: 'P', CCG: 'P',
  CGA: 'R', CGU: 'R', CGC: 'R', CGG: 'R',
  GAA: 'E', GAU: 'D', GAC: 'D', GAG: 'E',
  GUA: 'V', GUU: 'V', GUC: 'V', GUG: 'V',
  GCA: 'A', GCU: 'A', GCC: 'A', GCG: 'A',
  GGA: 'G', GGU: 'G', GGC: 'G', GGG: 'G'
}

// Lookup table for converting DNA codons to one-letter amino acid codes
var DNA_TO_AMINES = exports.DNA_TO_AMINES = {
  AAA: 'K', AAT: 'N', AAC: 'N', AAG: 'K',
  ATA: 'I', ATT: 'I', ATC: 'I', ATG: 'M',
  ACA: 'T', ACT: 'T', ACC: 'T', ACG: 'T',
  AGA: 'R', AGT: 'S', AGC: 'S', AGG: 'R',
  TAA: ' ', TAT: 'Y', TAC: 'Y', TAG: ' ',
  TTA: 'L', TTT: 'F', TTC: 'F', TTG: 'L',
  TCA: 'S', TCT: 'S', TCC: 'S', TCG: 'S',
  TGA: ' ', TGT: 'C', TGC: 'C', TGG: 'W',
  CAA: 'Q', CAT: 'H', CAC: 'H', CAG: 'Q',
  CTA: 'L', CTT: 'L', CTC: 'L', CTG: 'L',
  CCA: 'P', CCT: 'P', CCC: 'P', CCG: 'P',
  CGA: 'R', CGT: 'R', CGC: 'R', CGG: 'R',
  GAA: 'E', GAT: 'D', GAC: 'D', GAG: 'E',
  GTA: 'V', GTT: 'V', GTC: 'V', GTG: 'V',
  GCA: 'A', GCT: 'A', GCC: 'A', GCG: 'A',
  GGA: 'G', GGT: 'G', GGC: 'G', GGG: 'G'
}

// Lookup table for converting one-letter amino acid codes to DNA codons
var AMINES_TO_DNA = exports.AMINES_TO_DNA = {
  K: ['AAA', 'AAG'],
  N: ['AAC', 'AAU'],
  T: ['ACA', 'ACC', 'ACG', 'ACU'],
  R: ['AGA', 'AGG', 'CGA', 'CGC', 'CGG', 'CGU'],
  S: ['AGC', 'AGU', 'UCA', 'UCC', 'UCG', 'UCU'],
  I: ['AUA', 'AUC', 'AUU'],
  M: ['AUG'],
  Q: ['CAA', 'CAG'],
  H: ['CAC', 'CAU'],
  P: ['CCA', 'CCC', 'CCG', 'CCU'],
  L: ['CUA', 'CUC', 'CUG', 'CUU', 'UUA', 'UUG'],
  E: ['GAA', 'GAG'],
  D: ['GAC', 'GAU'],
  A: ['GCA', 'GCC', 'GCG', 'GCU'],
  G: ['GGA', 'GGC', 'GGG', 'GGU'],
  V: ['GUA', 'GUC', 'GUG', 'GUU'],
  Y: ['UAC', 'UAU'],
  C: ['UGC', 'UGU'],
  W: ['UGG'],
  F: ['UUC', 'UUU'],
  ' ': ['UAA', 'UAG', 'UGA']
}

// Converts a given DNA string to an amine string.  Assumes sequence begins with the first nucleotide given
var dnaToAmines = exports.dnaToAmines = function dnaToAmines(sequence) {
  var result = '';
  
  for(var i = 0, end = Math.floor(sequence.length/3); i < end; ++i) {
    result += DNA_TO_AMINES[sequence.substr(3*i, 3)];
    
    if(result[i] === ' ') return result.substring(0, i);
  }
  
  return result;
}

// Searches a DNA sequence for subsequences encoding the given peptide.  Also checks reverse complement
var findPeptideInDna = exports.findPeptideInDna = function findPeptideInDna(sequence, peptide) {
  var results = [];
  var dnaLength = 3*peptide.length;
  var sequenceRC = reverseComplement(sequence);
  
  for(var i = 0, end = sequence.length - dnaLength; i <= end; ++i) {
    if(peptide === dnaToAmines(sequence.substr(i, dnaLength))) {
      results.push(sequence.substr(i, dnaLength));
    }
    if(peptide === dnaToAmines(sequenceRC.substr(i, dnaLength))) {
      results.push(reverseComplement(sequenceRC.substr(i, dnaLength)));
    }
  }
  
  return results;
}

// Lookup table for converting one- and three-letter amino acid codes to monoisotopic masses
var AMINES_TO_MASSES = exports.AMINES_TO_MASSES = {
  A:  71, Ala:  71,
  R: 156, Arg: 156,
  N: 114, Asn: 114,
  D: 115, Asp: 115,
  C: 103, Cys: 103,
  E: 129, Glu: 129,
  Q: 128, Gln: 128,
  G:  57, Gly:  57,
  H: 137, His: 137,
  I: 113, Ile: 113,
  L: 113, Leu: 113,
  K: 128, Lys: 128,
  M: 131, Met: 131,
  F: 147, Phe: 147,
  P:  97, Pro:  97,
  S:  87, Ser:  87,
  T: 101, Thr: 101,
  W: 186, Trp: 186,
  Y: 163, Tyr: 163,
  V:  99, Val:  99
}

var AMINES_1L = exports.AMINES_1L = {
  A:  71, R: 156, N: 114, D: 115, C: 103,
  E: 129, Q: 128, G:  57, H: 137, I: 113,
  L: 113, K: 128, M: 131, F: 147, P:  97,
  S:  87, T: 101, W: 186, Y: 163, V:  99
}

var MASSES_TO_AMINES = exports.MASSES_TO_AMINES = {
   57: 'G',  71: 'A',  87: 'S' ,  97: 'P' ,
   99: 'V', 101: 'T', 103: 'C' , 113: 'IL',
  114: 'N', 115: 'D', 128: 'KQ', 129: 'E' ,
  131: 'M', 137: 'H', 147: 'F' , 156: 'R' ,
  163: 'Y', 186: 'W'
}

// Peptide string or mass array -> monoisotopic mass
var peptideToMass = exports.peptideToMass = function peptideToMass(peptide) {
  var result = 0;
  
  if(typeof peptide === 'string') for(var i = 0, end = peptide.length; i < end; ++i) {
    result += AMINES_TO_MASSES[peptide[i]];
  }
  
  // instanceof operator doesn't work well with REPL, so use workaround
  if(peptide.constructor.name === 'Array') for(var i = 0, end = peptide.length; i < end; ++i) {
    result += peptide[i];
  }
  
  return result;
}

// Generate full set of possible subpeptides (including the empty and original peptides)
var peptideToSubpeptides = exports.peptideToSubpeptides = function peptideToSubpeptides(peptide, cyclic) {
  var results;
  if(typeof peptide === 'string') results = ['', peptide];
  if(peptide.constructor.name === 'Array') results = [[], peptide];
  
  // Need double peptide string/array for handling cyclic peptides, and save the length
  var length = peptide.length;
  peptide = peptide.concat(peptide);
  
  if(typeof peptide === 'string') for(var i = 0; i < length; ++i) for(var j = 1, end = cyclic ? length : length - i; j < end; ++j) {
    results.push(peptide.substr(i, j));
  }
  
  if(peptide.constructor.name === 'Array') {
    for(var i = 0; i < length; ++i) for(var j = 1, end = cyclic ? length : length - i; j < end; ++j) {
      results.push(peptide.slice(i, i + j));
    }
  }
  
  return results;
}

// Generate a theoretical mass spec spectrum from the given peptide
var peptideToSpectrum = exports.peptideToSpectrum = function peptideToSpectrum(peptide, cyclic, noDuplicates) {
  var results = [], subpeptides = [];
  
  subpeptides = peptideToSubpeptides(peptide, cyclic);
  
  for(var i = 0, length = subpeptides.length; i < length; ++i) {
    subpeptides[i] = peptideToMass(subpeptides[i]);
  }
  
  subpeptides.sort(function(a, b) {
    if (a < b)
      return -1;
    if (a > b)
      return 1;
    return 0;
  });
  
  // Cull duplicates
  if(noDuplicates) for(var i = 0, length = subpeptides.length; i < length; ++i) {
    if(subpeptides[i] !== subpeptides[i + 1]) results.push(subpeptides[i]);
  }
  else {
    results = subpeptides;
  }
  
  return results;
}

// useConvolution uses the convoluteSpectrum method to determine animes to be used
var spectrumToPeptides = exports.spectrumToPeptides = function spectrumToPeptides(spectrum, N, cyclic, useConvolution, M) {
  if(typeof spectrum === 'string') console.log('String spectra are not usable - only mass array spectra');
  
  var results = [], candidates = [[]], branches = [], testSpectrum = [],
    testSpectrumIsEqual = false, testSpectrumIsConsistent = false,
    commonMasses = 0, scoredBranches = [], spectrumParentMass = 0,
    spectrumMassCounts = {}, testSpectrumMassCounts = {}, amineMasses;
  
  if(useConvolution) amineMasses = convoluteSpectrum(spectrum, true, M);
  else amineMasses = MASSES_TO_AMINES;
  
  for(var i = 0, endi = spectrum.length; i < endi; ++i) {
    spectrumMassCounts[spectrum[i]] = (spectrumMassCounts[spectrum[i]] || 0) + 1;
    if(spectrum[i] > spectrumParentMass) spectrumParentMass = spectrum[i];
  }
  
  for(var i = 0; i < N; ++i) results.push({score: -1});
  
  while(candidates.length > 0) {
    // Clean out branches and repopulate during branching
    branches = [];
    
    // Branch
    for(var i = 0, endi = candidates.length; i < endi; ++i) {
      for(var j in amineMasses) {
        branches.push(candidates[i].concat([Number(j)]));
      }
    }
    
    // Clean out candidates and repopulate during culling
    candidates = [];
    scoredBranches = [];
    
    // Cull
    for(var i = 0, endi = branches.length; i < endi; ++i) {
      // Reject overweight peptides - they can't be a good sequence
      if(peptideToMass(branches[i]) > spectrumParentMass) continue;
      
      testSpectrum = peptideToSpectrum(branches[i], cyclic);
      
      // Test new branches' theoretical spectra for # of masses in common with the given spectrum
      commonMasses = 0;
      testSpectrumMassCounts = {};
      
      for(var j = 0, endj = testSpectrum.length; j < endj; ++j) {
        testSpectrumMassCounts[testSpectrum[j]] = (testSpectrumMassCounts[testSpectrum[j]] || 0) + 1;
      }
      for(var j in testSpectrumMassCounts) {
        commonMasses += Math.min((spectrumMassCounts[j] || 0), testSpectrumMassCounts[j]);
      }
      
      scoredBranches.push({score: commonMasses, peptide: branches[i]});
    }
    
    // Sort branches by descending score...
    scoredBranches.sort(function(a, b) {
      if (a.score < b.score)
        return 1;
      if (a.score > b.score)
        return -1;
      return 0;
    });
    
    // ...and keep the top N...
    candidates = scoredBranches.slice(0, N);
    
    // ...including ties
    while(candidates[candidates.length - 1] && candidates[candidates.length - 1].score === scoredBranches[candidates.length] && scoredBranches[candidates.length].score) {
      candidates.push(scoredBranches[candidates.length]);
    }
    
    // Update results array with high scorers
    results = results.concat(candidates);
    results.sort(function(a, b) {
      if (a.score < b.score)
        return 1;
      if (a.score > b.score)
        return -1;
      return 0;
    });
    results.splice(N);
    
    // Turn scored peptide objects back into normal peptides
    candidates = candidates.map(function(item) {
      return item.peptide;
    });
    
    //console.log({scoredBranches: scoredBranches, candidates: candidates});
  }
  
  return results;
}

// Given mass spectrum, returns the convolution, including multiples
// The convolution used is also the complete list of deltas possible between the given spectrum's masses
// onlyAmines - set true to only return delta counts in the 57-200 range
// M - return only M most common deltas
var convoluteSpectrum = exports.convoluteSpectrum = function convoluteSpectrum(spectrum, onlyAmines, M) {
  var results = {}, current = 0, frequencies = [];
  
  for(var i = 0, end = spectrum.length; i < end; ++i) {
    for(var j = i + 1; j < end; ++j) {
      current = Math.abs(spectrum[i] - spectrum[j]);
      if(onlyAmines && (current < 57 || current > 200)) continue;
      results[current] = (results[current] || 0) + 1;
    }
  }
  
  if(typeof M !== 'undefined') {
    for(var i in results) frequencies.push(results[i]);
    
    frequencies.sort(function(a, b) {
      if (a < b)
        return 1;
      if (a > b)
        return -1;
      return 0;
    });
    
    for(var i in results) {
      if(results[i] < frequencies[M - 1]) delete results[i];
    }
  }
  
  return results;
}

})(typeof exports === 'undefined' ? (DNA = new Object()) : exports) // Module pattern
