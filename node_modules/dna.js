(function(exports) {

// Reverse and complement DNA string
var reverseComplement = exports.reverseComplement = function reverseComplement(string) {
  var result = '', complements = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'};
  
  // Step backwards through array for reverse iteration
  for(var i = string.length; i--;) {
    result += complements[string[i]];
  }
  
  return result;
}

// Find all matches of pattern in sequence
var findMatches = exports.findMatches = function findMatches(sequence, pattern) {
  var result = [];
  
  for(var last = sequence.indexOf(pattern); last !== -1; last = sequence.indexOf(pattern, last + 1)) {
    result.push(last);
  }
  
  return result;
}

// Find near matches of pattern in sequence, with no more than d mismatched nucleotides
var findApproximateMatches = exports.findApproximateMatches = function findApproximateMatches(sequence, pattern, d) {
  var result = [], subsequence = '', k = pattern.length, differences = 0;
  
  for(var position = 0, end = sequence.length - pattern.length; position <= end; ++position) {
    subsequence = sequence.substr(position, k);
    
    differences = 0;
    for(var j = 0; j < k; ++j) {
      if(subsequence[j] !== pattern[j]) ++differences;
    }
    
    if(differences <= d) result.push(position);
  }
  
  return result;
}

// Find all clumps of kmers which appear at least t times in any substring of length L in the given genome
var findClumps = exports.findClumps = function findClumps (genome, k, L, t) {
  var results = [], clumps = {}, kmers = {}, newString = '', oldString = '';
  
  for(var position = 0, end = genome.length - k; position <= end; ++position) {
    // Catalogue each kmer in kmers object, and remove old kmers from before the current substring of length L
    newString = genome.substr(position, k);
    kmers[newString] = (kmers[newString] || 0) + 1;
    if(position >= L) --kmers[genome.substr(position - L, k)];
    
    // Check for clumps
    if(kmers[newString] >= t) clumps[newString] = {};
  }
  
  for(var i in clumps) results.push(i);
  return results;
}

// Find indices of minimum G - C skew (0 based indexing)
var minimumSkew = exports.minimumSkew = function minimumSkew(sequence) {
  var lowestPoints = [-1], lowestValue = 0, skew = 0, skewValue = {'A': 0, 'T': 0, 'C': -1, 'G': 1};
  
  for(var i = 0, length = sequence.length; i < length; ++i) {
    skew += skewValue[sequence[i]];
    
    if(skew === lowestValue) {
      lowestPoints.push(i);
    }
    if(skew < lowestValue) {
      lowestPoints = [i];
      lowestValue = skew;
    }
  }

  return {points: lowestPoints, value: lowestValue};
}

// Find most common kmer(s) in sequence
var frequentWords = exports.frequentWords = function frequentWords(sequence, k) {
  var kmers = {}, frequentKmers = [], highestFrequency = 0, subsequence = '';
  
  for(var i = 0, end = sequence.length - k; i <= end; ++i) {
    subsequence = sequence.substr(i, k);
    
    kmers[subsequence] = (kmers[subsequence] || 0) + 1;
    if(kmers[subsequence] === highestFrequency) {
      frequentKmers.push(subsequence);
    }
    if(kmers[subsequence] > highestFrequency) {
      frequentKmers = [subsequence];
      highestFrequency = kmers[subsequence];
    }
  }
  
  return {frequency: highestFrequency, kmers: frequentKmers};
}

var changeBase = exports.changeBase = {
  'A': {'T': 1, 'C': 2, 'G': 3},
  'T': {'C': 1, 'G': 2, 'A': 3},
  'C': {'G': 1, 'A': 2, 'T': 3},
  'G': {'A': 1, 'T': 2, 'C': 3}
};

// Find most common kmer(s) in sequence, counting occurences of a kmer with no more than d differences (rather than exact occurences)
// If complements option is true, count kmers together with their complements
var frequentApproximateWords = exports.frequentApproximateWords = function frequentApproximateWords(sequence, k, d, complements) {
  if(d > 3) throw new Error('Sorry, I can only do d values of up to 3');
  console.warn('This function is complicated and untested - use at your own (high) risk')
  
  var kmers = {}, frequentKmers = [], highestFrequency = 0, subsequence = '', nearSubsequece = '', frequency = 0;
  
  for(var i = 0, end = sequence.length - k; i <= end; ++i) {
    subsequence = sequence.substr(i, k);
    
    // Make note of the subsequence, along with all similar subsequences
    kmers[subsequence] = (kmers[subsequence] || 0) + 1;
    if(d >= 1) for(var i2 = 0; i2 < k; ++i2) for(var i3 in changeBase[subsequence[i2]]) {
      nearSubsequence = subsequence.substring(0, i2) + i3 + subsequence.substring(i2 + 1);
      kmers[nearSubsequence] = (kmers[nearSubsequence] || 0) + 1;
    }
    if(d >= 2) for(var i2 = 0; i2 < k; ++i2) for(var i3 = i2 + 1; i3 < k; ++i3) {
      for(var i4 in changeBase[subsequence[i2]]) for(var i5 in changeBase[subsequence[i3]]) {
        nearSubsequence = subsequence.substring(0, i2) + i4 + subsequence.substring(i2 + 1, i3) + i5 + subsequence.substring(i3 + 1);
        kmers[nearSubsequence] = (kmers[nearSubsequence] || 0) + 1;
      }
    }
    if(d >= 3) for(var i2 = 0; i2 < k; ++i2) for(var i3 = i2 + 1; i3 < k; ++i3) for(var i4 = i3 + 1; i4 < k; ++i4) {
      for(var i5 in changeBase[subsequence[i2]]) for(var i6 in changeBase[subsequence[i3]]) for(var i7 in changeBase[subsequence[i4]]) {
        nearSubsequence = subsequence.substring(0, i2) + i5 + subsequence.substring(i2 + 1, i3) + i6 + subsequence.substring(i3 + 1, i4) + i7 + subsequence.substring(i4 + 1);
        kmers[nearSubsequence] = (kmers[nearSubsequence] || 0) + 1;
      }
    }
  }
  
  for(var i in kmers) {
    frequency = kmers[i] + (complements ? kmers[reverseComplement(i)] : 0);
    
    if(frequency === highestFrequency) {
      frequentKmers.push(i);
    }
    if(frequency > highestFrequency) {
      frequentKmers = [i];
      highestFrequency = frequency;
    }
  }
  
  return {frequency: highestFrequency, kmers: frequentKmers};
}

// Given key list of dna strands, find any (k, d)-motif appearing in each
var findMotifs = exports.findMotifs = function findMotifs(dnas, k, d) {
  var kmers = {}, kmersWithDiffs = {}, results = {}, isPresent = false;
  
  if(dnas.constructor.name !== 'Object') throw new TypeError('Parameter \'dnas\' must be a key list of dna strings');
  
  // Enumerate all kmers
  for(var dna in dnas) {
    for(var i = 0, endi = dna.length - k; i <= endi; ++i) {
      kmers[dna.substr(i, k)] = true;
    }
  }
  
  // Enumerate all kmers with no more than d differences from the original kmers
  kmersWithDiffs = listVariations(kmers, d);
  
  // Screen for appearance in each strand
  for(var kmer in kmersWithDiffs) {
    isPresent = true;
    
    for(var dna in dnas) {
      if(hammingDistance(kmer, dna) > d) isPresent = false;
    }
    
    if(isPresent) results[kmer] = true;
  }
  
  return results;
}

// Find median k-mer for key list sequences by brute force
var bruteForceMedianString = exports.bruteForceMedianString = function bruteForceMedianString(sequences, k) {
  var result = '', allPossibleKmers = {}, distance = 0, bestDistance = Number.MAX_VALUE;
  for(var i = 0; i < k; ++i) result += 'A';
  
  // List every possibility...
  allPossibleKmers[result] = true;
  allPossibleKmers = listVariations(allPossibleKmers, k);
  
  // ...and find the closest
  for(var kmer in allPossibleKmers) {
    distance = 0;
    
    for(var sequence in sequences) {
      distance += hammingDistance(kmer, sequence);
    }
    
    if(distance < bestDistance) {
      bestDistance = distance;
      result = kmer;
    }
  }
  
  return result;
}

// Find hamming distance between two strings...just like it sounds
var hammingDistance = exports.hammingDistance = function hammingDistance(s1, s2) {
  // If both strings are the same length, they can be put either variable
  var short = s1.length > s2.length ? s2 : s1;
  var long  = s1.length > s2.length ? s1 : s2;
  var distanceCurrent, distance = Number.MAX_VALUE;
  
  for(var i = 0, endi = long.length - short.length; i <= endi; ++i) {
    distanceCurrent = 0;
    
    for(var j = 0, endj = short.length; j < endj; ++j) {
      if(short[j] !== long[i + j]) ++distanceCurrent;
    }
    
    if(distanceCurrent < distance) distance = distanceCurrent;
  }
  
  return distance;
}

// List all variations of a key list of sequences with at most d differencs from one of the originals
// 'sequences' must be represented as an object with keys matching the desired sequences, for ease of implementation
var listVariations = exports.listVariations = function listVariations(sequences, d) {
  if(sequences.constructor.name !== 'Object') throw new TypeError('Parameter \'sequences\' must be represented as a key list');
  
  var results = {};
  for(var sequence in sequences) results[sequence] = true;
  
  if(d === 0) return results;
  
  if(d > 0) {
    for(var sequence in sequences) {
      for(var j = 0, endj = sequence.length; j < endj; ++j) {
        for(var k in changeBase[sequence[j]]) {
          results[sequence.substring(0, j) + k + sequence.substring(j + 1)] = true;
        }
      }
    }
  }
  
  if(d === 1) return results;
  
  if(d > 1) {
    return listVariations(results, d - 1);
  }
}

// Form probability profile from array of sequences.  Assumes sequences are the same length
// If nonzero is true, all values will be increased by 0.001
var profileFromSequences = exports.profileFromSequences = function(sequences, nonzero) {
  var results = [], counts = {}, countsZero = 0, total = 0;
  
  countsZero = nonzero ? 1 : 0;
  total = nonzero ? sequences.length + 4 : sequences.length;
  
  for(var i = 0, endi = sequences[0].length; i < endi; ++i) {
    counts = {A: countsZero, T: countsZero, C: countsZero, G: countsZero};
    
    for(var j = 0, endj = sequences.length; j < endj; ++j) {
      ++counts[sequences[j][i]];
    }
    
    results.push({A: counts.A/total, T: counts.T/total, C: counts.C/total, G: counts.G/total});
  }
  
  return results;
}

// Scores an array of sequences by total hamming distance from the median string of the same length
// Assumes all given sequences are the same length
var hammingDistanceSet = exports.hammingDistanceSet = function(sequences) {
  var result = 0, counts = {};
  
  for(var i = 0, endi = sequences[0].length; i < endi; ++i) {
    counts = {A: 0, T: 0, C: 0, G: 0};
    
    for(var j = 0, endj = sequences.length; j < endj; ++j) {
      ++counts[sequences[j][i]];
    }
    
    result += endj - Math.max(counts.A, counts.T, counts.C, counts.G);
  }
  
  return result;
}

// Find most probable k-mer in given sequence.  Probability profile is specified as:
// [index_1_probabilities, index_2_probabilities, ...] where each set of probabilities is as:
// {A: p_of_A, T: p_of_T, C: p_of_C, G: p_of_G}
var mostProbableKmerFromProfile = exports.mostProbableKmerFromProfile = function(profile, sequence, k) {
  var result = sequence.slice(0, k), probability = 0, bestProbability = 0;
  
  for(var i = 0, endi = sequence.length - k; i <= endi; ++i) {
    probability = 1;
    
    for(var j = 0; j < k; ++j) {
      probability *= profile[j][sequence[i + j]];
    }
    
    if(probability > bestProbability) {
      bestProbability = probability;
      result = sequence.slice(i, i + k)
    }
  }
  
  return result;
}

// Randomly select k-mer in given sequence, with probabilities determined by a profile.  Probability profile specified as:
// [index_1_probabilities, index_2_probabilities, ...] where each set of probabilities is as:
// {A: p_of_A, T: p_of_T, C: p_of_C, G: p_of_G}
var randomKmerFromProfile = exports.randomKmerFromProfile = function(profile, sequence, k) {
  var probability = 0, probabilities = [], probabilityTotal = 0, random = 0;
  
  for(var i = 0, endi = sequence.length - k; i <= endi; ++i) {
    probability = 1;
    
    for(var j = 0; j < k; ++j) {
      probability *= profile[j][sequence[i + j]];
    }
    
    probabilities.push(probability);
    probabilityTotal += probability;
  }
  
  random = Math.random()*probabilityTotal;
  probabilityTotal = 0;
  
  for(var i = 0, endi = sequence.length - k; i <= endi; ++i) {
    probabilityTotal += probabilities[i];
    if(random < probabilityTotal) {
      return sequence.slice(i, i + k);
    }
  }
}

// find (k, lowest d)-motifs in given array of dnas with a greedy algorithm
// I think the t parameter is supposed to be same as the number of sequences in dnas, so I removed it in favor dnas.length
// If nonzero is true, allows internally generated probability profiles to have zero-entries.  This should always be used, except
//   when doing work graded by a buggy algorithm that uses zero-entries
var greedyMotifSearch = exports.greedyMotifSearch = function(dnas, k, allowZeroes) {
  var results = [], motifs = [], bestScore = Number.MAX_VALUE;
  
  // Sane initial value for results, just in case
  for(var i = 0, endi = dnas.length; i < endi; ++i) {
    results.push(dnas[i].slice(0, k));
  }
  bestScore = hammingDistanceSet(results);
  
  for(var i = 0, endi = dnas[0].length - k; i <= endi; ++i) {
    motifs = [];
    motifs[0] = dnas[0].slice(i, i + k);
    
    for(var j = 1, endj = dnas.length; j < endj; ++j) {
      motifs.push(mostProbableKmerFromProfile(profileFromSequences(motifs, !allowZeroes), dnas[j], k));
    }
    
    if(hammingDistanceSet(motifs) < bestScore) {
      bestScore = hammingDistanceSet(motifs);
      results = motifs.slice();
    }
  }
  
  return results;
}

// Runs a specified search algorithm [algorithmm] number of times [outerIterations] and returns the most frequent result
// Passed to [algorithm]: [dnas] is an array of equal-length sequences, [k] is k-mer length, and [iterations]
var monteCarloMotifSearch = exports.monteCarloMotifSearch = function(dnas, k, iterations, algorithm, outerIterations) {
  var outputs = {}, output = [], result = [], highestFrequency = 0;
  
  for(var i = 0; i < outerIterations; ++i) {
    output = JSON.stringify(algorithm(dnas, k, iterations));
    outputs[output] = (outputs[output] || 0) + 1;
  }
  
  for(var i in outputs) {
    if(outputs[i] > highestFrequency) {
      highestFrequency = outputs[i];
      result = JSON.parse(i);
    }
  }
  
  return result;
}

// Iterative search for motifs based on random seed.  Returns after first regression
// dnas is an array of equal-length sequences
var randomizedMotifSearch = exports.randomizedMotifSearch = function(dnas, k) {
  var results = [], motifs = [], bestScore = Number.MAX_VALUE, random = 0, profile = [], length = dnas.length;
  
  for(var i = 0; i < length; ++i) {
    random = Math.floor(Math.random()*(dnas[i].length - k + 1));
    motifs.push(dnas[i].slice(random, random + k));
  }
  results = motifs.slice();
  bestScore = hammingDistanceSet(results);
  
  while(true) {
    profile = profileFromSequences(results, true);
    
    for(var i = 0; i < length; ++i) {
      motifs[i] = mostProbableKmerFromProfile(profile, dnas[i], k);
    }
    
    if(hammingDistanceSet(motifs) < bestScore) {
      bestScore = hammingDistanceSet(results);
      results = motifs.slice();
    }
    else return results;
  }
}

// Iterative search for motifs based on random seed and gibbs sampling.  Returns after [iterations] resamples
// dnas is an array of equal-length sequences
var gibbsMotifSearch = exports.gibbsMotifSearch = function(dnas, k, iterations) {
  var results = [], motifs = [], workingMotif = '', bestScore = Number.MAX_VALUE, random = 0, profile = [], length = dnas.length;
  
  for(var i = 0; i < length; ++i) {
    random = Math.floor(Math.random()*(dnas[i].length - k + 1));
    motifs.push(dnas[i].slice(random, random + k));
  }
  results = motifs.slice();
  bestScore = hammingDistanceSet(results);
  
  for(var i = 0; i < iterations; ++i) {
    random = Math.floor(Math.random()*length);
    
    workingMotif = motifs.splice(random, 1);
    
    profile = profileFromSequences(motifs, true);
    
    motifs.splice(random, 0, randomKmerFromProfile(profile, dnas[random], k))
    
    if(hammingDistanceSet(motifs) < bestScore) {
      bestScore = hammingDistanceSet(results);
      results = motifs.slice();
    }
  }
  
  return results;
}

// Lookup table for converting DNA nucleotides to RNA
var DNA_TO_RNA = exports.DNA_TO_RNA = {'A': 'A', 'T': 'U', 'C': 'C', 'G': 'G'};

// Lookup table for converting RNA codons to one-letter amino acid codes
var RNA_TO_AMINES = exports.RNA_TO_AMINES = {
  AAA: 'K', AAU: 'N', AAC: 'N', AAG: 'K',
  AUA: 'I', AUU: 'I', AUC: 'I', AUG: 'M',
  ACA: 'T', ACU: 'T', ACC: 'T', ACG: 'T',
  AGA: 'R', AGU: 'S', AGC: 'S', AGG: 'R',
  UAA: ' ', UAU: 'Y', UAC: 'Y', UAG: ' ',
  UUA: 'L', UUU: 'F', UUC: 'F', UUG: 'L',
  UCA: 'S', UCU: 'S', UCC: 'S', UCG: 'S',
  UGA: ' ', UGU: 'C', UGC: 'C', UGG: 'W',
  CAA: 'Q', CAU: 'H', CAC: 'H', CAG: 'Q',
  CUA: 'L', CUU: 'L', CUC: 'L', CUG: 'L',
  CCA: 'P', CCU: 'P', CCC: 'P', CCG: 'P',
  CGA: 'R', CGU: 'R', CGC: 'R', CGG: 'R',
  GAA: 'E', GAU: 'D', GAC: 'D', GAG: 'E',
  GUA: 'V', GUU: 'V', GUC: 'V', GUG: 'V',
  GCA: 'A', GCU: 'A', GCC: 'A', GCG: 'A',
  GGA: 'G', GGU: 'G', GGC: 'G', GGG: 'G'
}

// Lookup table for converting DNA codons to one-letter amino acid codes
var DNA_TO_AMINES = exports.DNA_TO_AMINES = {
  AAA: 'K', AAT: 'N', AAC: 'N', AAG: 'K',
  ATA: 'I', ATT: 'I', ATC: 'I', ATG: 'M',
  ACA: 'T', ACT: 'T', ACC: 'T', ACG: 'T',
  AGA: 'R', AGT: 'S', AGC: 'S', AGG: 'R',
  TAA: ' ', TAT: 'Y', TAC: 'Y', TAG: ' ',
  TTA: 'L', TTT: 'F', TTC: 'F', TTG: 'L',
  TCA: 'S', TCT: 'S', TCC: 'S', TCG: 'S',
  TGA: ' ', TGT: 'C', TGC: 'C', TGG: 'W',
  CAA: 'Q', CAT: 'H', CAC: 'H', CAG: 'Q',
  CTA: 'L', CTT: 'L', CTC: 'L', CTG: 'L',
  CCA: 'P', CCT: 'P', CCC: 'P', CCG: 'P',
  CGA: 'R', CGT: 'R', CGC: 'R', CGG: 'R',
  GAA: 'E', GAT: 'D', GAC: 'D', GAG: 'E',
  GTA: 'V', GTT: 'V', GTC: 'V', GTG: 'V',
  GCA: 'A', GCT: 'A', GCC: 'A', GCG: 'A',
  GGA: 'G', GGT: 'G', GGC: 'G', GGG: 'G'
}

// Lookup table for converting one-letter amino acid codes to DNA codons
var AMINES_TO_DNA = exports.AMINES_TO_DNA = {
  K: ['AAA', 'AAG'],
  N: ['AAC', 'AAU'],
  T: ['ACA', 'ACC', 'ACG', 'ACU'],
  R: ['AGA', 'AGG', 'CGA', 'CGC', 'CGG', 'CGU'],
  S: ['AGC', 'AGU', 'UCA', 'UCC', 'UCG', 'UCU'],
  I: ['AUA', 'AUC', 'AUU'],
  M: ['AUG'],
  Q: ['CAA', 'CAG'],
  H: ['CAC', 'CAU'],
  P: ['CCA', 'CCC', 'CCG', 'CCU'],
  L: ['CUA', 'CUC', 'CUG', 'CUU', 'UUA', 'UUG'],
  E: ['GAA', 'GAG'],
  D: ['GAC', 'GAU'],
  A: ['GCA', 'GCC', 'GCG', 'GCU'],
  G: ['GGA', 'GGC', 'GGG', 'GGU'],
  V: ['GUA', 'GUC', 'GUG', 'GUU'],
  Y: ['UAC', 'UAU'],
  C: ['UGC', 'UGU'],
  W: ['UGG'],
  F: ['UUC', 'UUU'],
  ' ': ['UAA', 'UAG', 'UGA']
}

// Converts a given DNA string to an amine string.  Assumes sequence begins with the first nucleotide given
var dnaToAmines = exports.dnaToAmines = function dnaToAmines(sequence) {
  var result = '';
  
  for(var i = 0, end = Math.floor(sequence.length/3); i < end; ++i) {
    result += DNA_TO_AMINES[sequence.substr(3*i, 3)];
    
    if(result[i] === ' ') return result.substring(0, i);
  }
  
  return result;
}

// Searches a DNA sequence for subsequences encoding the given peptide.  Also checks reverse complement
var findPeptideInDna = exports.findPeptideInDna = function findPeptideInDna(sequence, peptide) {
  var results = [];
  var dnaLength = 3*peptide.length;
  var sequenceRC = reverseComplement(sequence);
  
  for(var i = 0, end = sequence.length - dnaLength; i <= end; ++i) {
    if(peptide === dnaToAmines(sequence.substr(i, dnaLength))) {
      results.push(sequence.substr(i, dnaLength));
    }
    if(peptide === dnaToAmines(sequenceRC.substr(i, dnaLength))) {
      results.push(reverseComplement(sequenceRC.substr(i, dnaLength)));
    }
  }
  
  return results;
}

// Lookup table for converting one- and three-letter amino acid codes to monoisotopic masses
var AMINES_TO_MASSES = exports.AMINES_TO_MASSES = {
  A:  71, Ala:  71,
  R: 156, Arg: 156,
  N: 114, Asn: 114,
  D: 115, Asp: 115,
  C: 103, Cys: 103,
  E: 129, Glu: 129,
  Q: 128, Gln: 128,
  G:  57, Gly:  57,
  H: 137, His: 137,
  I: 113, Ile: 113,
  L: 113, Leu: 113,
  K: 128, Lys: 128,
  M: 131, Met: 131,
  F: 147, Phe: 147,
  P:  97, Pro:  97,
  S:  87, Ser:  87,
  T: 101, Thr: 101,
  W: 186, Trp: 186,
  Y: 163, Tyr: 163,
  V:  99, Val:  99
}

var AMINES_1L = exports.AMINES_1L = {
  A:  71, R: 156, N: 114, D: 115, C: 103,
  E: 129, Q: 128, G:  57, H: 137, I: 113,
  L: 113, K: 128, M: 131, F: 147, P:  97,
  S:  87, T: 101, W: 186, Y: 163, V:  99
}

var MASSES_TO_AMINES = exports.MASSES_TO_AMINES = {
   57: 'G',  71: 'A',  87: 'S' ,  97: 'P' ,
   99: 'V', 101: 'T', 103: 'C' , 113: 'IL',
  114: 'N', 115: 'D', 128: 'KQ', 129: 'E' ,
  131: 'M', 137: 'H', 147: 'F' , 156: 'R' ,
  163: 'Y', 186: 'W'
}

// Peptide string or mass array -> monoisotopic mass
var peptideToMass = exports.peptideToMass = function peptideToMass(peptide) {
  var result = 0;
  
  if(typeof peptide === 'string') for(var i = 0, end = peptide.length; i < end; ++i) {
    result += AMINES_TO_MASSES[peptide[i]];
  }
  
  // instanceof operator doesn't work well with REPL, so use workaround
  if(peptide.constructor.name === 'Array') for(var i = 0, end = peptide.length; i < end; ++i) {
    result += peptide[i];
  }
  
  return result;
}

// Generate full set of possible subpeptides (including the empty and original peptides)
var peptideToSubpeptides = exports.peptideToSubpeptides = function peptideToSubpeptides(peptide, cyclic) {
  var results;
  if(typeof peptide === 'string') results = ['', peptide];
  if(peptide.constructor.name === 'Array') results = [[], peptide];
  
  // Need double peptide string/array for handling cyclic peptides, and save the length
  var length = peptide.length;
  peptide = peptide.concat(peptide);
  
  if(typeof peptide === 'string') for(var i = 0; i < length; ++i) for(var j = 1, end = cyclic ? length : length - i; j < end; ++j) {
    results.push(peptide.substr(i, j));
  }
  
  if(peptide.constructor.name === 'Array') {
    for(var i = 0; i < length; ++i) for(var j = 1, end = cyclic ? length : length - i; j < end; ++j) {
      results.push(peptide.slice(i, i + j));
    }
  }
  
  return results;
}

// Generate a theoretical mass spec spectrum from the given peptide
var peptideToSpectrum = exports.peptideToSpectrum = function peptideToSpectrum(peptide, cyclic, noDuplicates) {
  var results = [], subpeptides = [];
  
  subpeptides = peptideToSubpeptides(peptide, cyclic);
  
  for(var i = 0, length = subpeptides.length; i < length; ++i) {
    subpeptides[i] = peptideToMass(subpeptides[i]);
  }
  
  subpeptides.sort(function(a, b) {
    if (a < b)
      return -1;
    if (a > b)
      return 1;
    return 0;
  });
  
  // Cull duplicates
  if(noDuplicates) for(var i = 0, length = subpeptides.length; i < length; ++i) {
    if(subpeptides[i] !== subpeptides[i + 1]) results.push(subpeptides[i]);
  }
  else {
    results = subpeptides;
  }
  
  return results;
}

// useConvolution uses the convoluteSpectrum method to determine animes to be used
var spectrumToPeptides = exports.spectrumToPeptides = function spectrumToPeptides(spectrum, N, cyclic, useConvolution, M) {
  if(typeof spectrum === 'string') console.log('String spectra are not usable - only mass array spectra');
  
  var results = [], candidates = [[]], branches = [], testSpectrum = [],
    testSpectrumIsEqual = false, testSpectrumIsConsistent = false,
    commonMasses = 0, scoredBranches = [], spectrumParentMass = 0,
    spectrumMassCounts = {}, testSpectrumMassCounts = {}, amineMasses;
  
  if(useConvolution) amineMasses = convoluteSpectrum(spectrum, true, M);
  else amineMasses = MASSES_TO_AMINES;
  
  for(var i = 0, endi = spectrum.length; i < endi; ++i) {
    spectrumMassCounts[spectrum[i]] = (spectrumMassCounts[spectrum[i]] || 0) + 1;
    if(spectrum[i] > spectrumParentMass) spectrumParentMass = spectrum[i];
  }
  
  for(var i = 0; i < N; ++i) results.push({score: -1});
  
  while(candidates.length > 0) {
    // Clean out branches and repopulate during branching
    branches = [];
    
    // Branch
    for(var i = 0, endi = candidates.length; i < endi; ++i) {
      for(var j in amineMasses) {
        branches.push(candidates[i].concat([Number(j)]));
      }
    }
    
    // Clean out candidates and repopulate during culling
    candidates = [];
    scoredBranches = [];
    
    // Cull
    for(var i = 0, endi = branches.length; i < endi; ++i) {
      // Reject overweight peptides - they can't be a good sequence
      if(peptideToMass(branches[i]) > spectrumParentMass) continue;
      
      testSpectrum = peptideToSpectrum(branches[i], cyclic);
      
      // Test new branches' theoretical spectra for # of masses in common with the given spectrum
      commonMasses = 0;
      testSpectrumMassCounts = {};
      
      for(var j = 0, endj = testSpectrum.length; j < endj; ++j) {
        testSpectrumMassCounts[testSpectrum[j]] = (testSpectrumMassCounts[testSpectrum[j]] || 0) + 1;
      }
      for(var j in testSpectrumMassCounts) {
        commonMasses += Math.min((spectrumMassCounts[j] || 0), testSpectrumMassCounts[j]);
      }
      
      scoredBranches.push({score: commonMasses, peptide: branches[i]});
    }
    
    // Sort branches by descending score...
    scoredBranches.sort(function(a, b) {
      if (a.score < b.score)
        return 1;
      if (a.score > b.score)
        return -1;
      return 0;
    });
    
    // ...and keep the top N...
    candidates = scoredBranches.slice(0, N);
    
    // ...including ties
    while(candidates[candidates.length - 1] && candidates[candidates.length - 1].score === scoredBranches[candidates.length] && scoredBranches[candidates.length].score) {
      candidates.push(scoredBranches[candidates.length]);
    }
    
    // Update results array with high scorers
    results = results.concat(candidates);
    results.sort(function(a, b) {
      if (a.score < b.score)
        return 1;
      if (a.score > b.score)
        return -1;
      return 0;
    });
    results.splice(N);
    
    // Turn scored peptide objects back into normal peptides
    candidates = candidates.map(function(item) {
      return item.peptide;
    });
    
    //console.log({scoredBranches: scoredBranches, candidates: candidates});
  }
  
  return results;
}

// Given mass spectrum, returns the convolution, including multiples
// The convolution used is also the complete list of deltas possible between the given spectrum's masses
// onlyAmines - set true to only return delta counts in the 57-200 range
// M - return only M most common deltas
var convoluteSpectrum = exports.convoluteSpectrum = function convoluteSpectrum(spectrum, onlyAmines, M) {
  var results = {}, current = 0, frequencies = [];
  
  for(var i = 0, end = spectrum.length; i < end; ++i) {
    for(var j = i + 1; j < end; ++j) {
      current = Math.abs(spectrum[i] - spectrum[j]);
      if(onlyAmines && (current < 57 || current > 200)) continue;
      results[current] = (results[current] || 0) + 1;
    }
  }
  
  if(typeof M !== 'undefined') {
    for(var i in results) frequencies.push(results[i]);
    
    frequencies.sort(function(a, b) {
      if (a < b)
        return 1;
      if (a > b)
        return -1;
      return 0;
    });
    
    for(var i in results) {
      if(results[i] < frequencies[M - 1]) delete results[i];
    }
  }
  
  return results;
}

// Returns composition-k of sequence as an array.  Composition-k is the set of kmers in sequence, including multiples
var composition = exports.composition = function(sequence, k) {
  var results = [];
  
  for(var i = 0, endi = sequence.length - k; i <= endi; ++i) {
    results.push(sequence.slice(i, i + k));
  }
  
  results.sort();
  return results;
}

// Given array of same-length sequences, return a graph of k-1 overlaps in special Coursera class format
var overlapGraphCoursera = exports.overlapGraphCoursera = function(sequences) {
  var results = [];
  var k = sequences[0].length;
  var sequenceCache = '';
  
  for(var i = 0, endi = sequences.length; i < endi; ++i) {
    // Last k-1 of kmer
    sequenceCache = sequences[i].slice(1);
    
    for(var j = 0; j < endi; ++j) {
      // Compare with first k-1 of other kmer
      if(sequenceCache === sequences[j].slice(0, -1)) {
        results.push(sequences[i] + ' -> ' + sequences[j]);
      }
    }
  }
  
  results.sort();
  return results;
}

/*
deBruijnFromKmers(fileToLines(''));

CONVERT DE BRUIJN GRAPH TO COURSERA FORMAT (remove repeat edges):
var output = _;
var formattedResults = [];
var string1 = '';
var string2 = '';
for(var i in output) {
  string1 = i + ' -> ';
  string2 = '';
  
  for(var j in output[i]) {
    //for(var k = 0; k < output[i][j]; ++k) {
      string2 += j + ',';
    //}
  }
  string2 = string2.slice(0, -1).split(',').sort().join(',');
  formattedResults.push(string1 + string2);
}
formattedResults.sort();
for(var i = 0; i < formattedResults.length; ++i) console.log(formattedResults[i]);
*/

// Given a sequence, form a De Bruijn graph from every kmer present
// Format {startNode1: {endNode1: 1, endNode2: 2, ...}, ...}
var deBruijnFromSequence = exports.deBruijnFromSequence = function(sequence, k) {
  var results = {}, startNode = '', endNode = '';
  
  // This graph is represented as a list of edges, and each kmer represents an edge
  for(var i = 0, endi = sequence.length - k + 1; i < endi; ++i) {
    // The node at the beginning of the edge is the k-1mer at the start of each kmer,
    // and the node at the end is the k-1mer at the end
    startNode = sequence.slice(i, i + k - 1);
    endNode = sequence.slice(i + 1, i + k);
    
    if(results[startNode] === undefined) results[startNode] = {};
    results[startNode][endNode] = (results[startNode][endNode] || 0) + 1;
  }
  
  return results;
}

// Given an array of same-length sequences, form a De Bruijn graph from every sequence present
// Format {startNode1: {endNode1: 1, endNode2: 2, ...}, ...}
var deBruijnFromKmers = exports.deBruijnFromKmers = function(sequences) {
  var results = {}, startNode = '', endNode = '', k = sequences[0].length;
  
  // This graph is represented as a list of edges, and each kmer represents an edge
  for(var i = 0, endi = sequences.length; i < endi; ++i) {
    // The node at the beginning of the edge is the k-1mer at the start of each kmer,
    // and the node at the end is the k-1mer at the end
    startNode = sequences[i].slice(0, -1);
    endNode = sequences[i].slice(1);
    
    if(results[startNode] === undefined) results[startNode] = {};
    results[startNode][endNode] = (results[startNode][endNode] || 0) + 1;
  }
  
  return results;
}

// Fetches a file as an array of lines (split on \n)
var fileToLines = exports.fileToLines = function(path) {
  var fs = require('fs');
  
  return fs.readFileSync(path, 'utf8').split('\n');
}

// Converts Coursera's text files to De Bruijn graphs
var courseraFileToDeBruijnGraph = exports.courseraFileToDeBruijnGraph = function(path) {
  var lines = fileToLines(path), result = {}, lineSplit = [], endNodes = [];
  
  for(var i = 0, endi = lines.length; i < endi; ++i) {
    lineSplit = lines[i].split(' -> ');
    endNodes = lineSplit[1].split(',');
    
    result[lineSplit[0]] = {};
    for(var j = 0, endj = endNodes.length; j < endj; ++j) {
      result[lineSplit[0]][endNodes[j]] = (result[lineSplit[0]][endNodes[j]] || 0) + 1;
    }
  }
  
  return result;
}

//_.toString().replace(/\,/g, '->')
// Returns Euler cycle as array of nodes visited
var eulerCycleFromDeBruijnGraph = exports.eulerCycleFromDeBruijnGraph = function(graph) {
  var result = [], currentNode = '', currentNodeIndex = 0, workingGraph = {}, nextNode = '', targetLength = 1;
  workingGraph = JSON.parse(JSON.stringify(graph));
  
  for(var i in graph) {
    for(var j in graph[i]) {
      targetLength += graph[i][j];
    }
  }
  
  // Choose any start
  for(var i in graph) {
    result[0] = currentNode = i;
    break;
  }
  
  while(result.length < targetLength) {
    // Walk on new paths until getting stuck
    while(true) {
      // Choose next node from those reachable
      nextNode = '';
      for(var i in workingGraph[currentNode]) {
        nextNode = i;
        break;
      }
      
      // If that didn't find one, there aren't any reachable from this node
      if(nextNode === '') break;
      
      // Remove graph entry for next edge
      if(--workingGraph[currentNode][nextNode] <= 0) delete workingGraph[currentNode][nextNode];
      
      result.push(currentNode = nextNode);
    }
    
    console.log('Found Euler cycle of length: ' + result.length);
    
    // Now find a node in the cycle just found with unused edges
    currentNodeIndex = NaN;
    for(var i = 0, endi = result.length; i < endi; ++i) {
      for(var j in workingGraph[result[i]]) {
        currentNodeIndex = i;
        break;
      }
    }
    
    // If no new node found, someone is wrong
    if(currentNodeIndex === NaN) break;
    
    // Rotate cycle in its array so that the new current node is at the end
    result = result.slice(currentNodeIndex).concat(result.slice(1, currentNodeIndex + 1));
    
    currentNode = result[result.length - 1];
  }
  
  return result;
}

})(typeof exports === 'undefined' ? (DNA = new Object()) : exports) // Module pattern
